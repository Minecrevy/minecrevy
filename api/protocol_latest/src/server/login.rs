use uuid::Uuid;

use minecrevy_io_str::{McRead, McWrite};
use minecrevy_key::Key;

/// Tells the client to start accepting encrypted packets, and start sending them.
#[derive(Clone, PartialEq, Debug, McRead, McWrite)]
pub struct EncryptionRequest {
    /// The server ID, usually empty.
    #[options(max_len = 20)]
    pub server: String,
    /// The server's public key.
    pub public_key: Vec<u8>,
    /// A sequence of random bytes generated by the server.
    pub verify_token: Vec<u8>,
}

impl crate::Packet for EncryptionRequest {}

/// Tells the client that login is finished.
#[derive(Clone, PartialEq, Debug, McRead, McWrite)]
pub struct LoginSuccess {
    /// The player's unique id.
    pub id: Uuid,
    /// The player's username.
    #[options(max_len = 16)]
    pub name: String,
}

impl crate::Packet for LoginSuccess {}

/// Tells the client to start accepting compressed packets, and start sending them.
#[derive(Clone, PartialEq, Debug, McRead, McWrite)]
pub struct Compression {
    /// Minimum size for a packet to be compressed.
    #[options(varint = true)]
    pub threshold: i32,
}

impl crate::Packet for Compression {}

/// Allows the implementation of a custom handshake flow.
///
/// See [plugin response][`crate::client::LoginPluginResponse`] for the client side.
#[derive(Clone, PartialEq, Debug, McRead, McWrite)]
pub struct LoginPluginRequest {
    /// Generated by the server. The client should reply with the same value.
    #[options(varint = true)]
    pub id: i32,
    /// The name of the server channel used to send data.
    pub channel: Key,
    /// The data being communicated.
    #[options(length = "remaining")]
    pub data: Vec<u8>,
}

impl crate::Packet for LoginPluginRequest {}
